{"ast":null,"code":"var _jsxFileName = \"/Users/madisonmccardle/PCA/javascipt/react/hacker-news-react-apollo/src/components/LinkList.js\";\nimport React, { Component } from 'react';\nimport Link from './Link';\nimport { Query } from 'react-apollo';\nimport gql from 'graphql-tag';\nexport const FEED_QUERY = gql`\n{\n  feed {\n    links {\n      id\n      createdAt\n      url\n      description\n      postedBy {\n        id\n        name\n      }\n      votes {\n        id\n        user {\n          id\n        }\n      }\n    }\n  }\n}\n`; // create the JavaScript constant called FEED_QUERY that stores the query.\n// The gql function is used to parse the plain string that contains the GraphQL code.\n\nclass LinkList extends Component {\n  constructor(...args) {\n    super(...args);\n\n    this._updateCacheAfterVote = (store, createVote, linkId) => {\n      const data = store.readQuery({\n        query: FEED_QUERY\n      }); // eading the current state of the cached data for the FEED_QUERY from the store\n\n      const votedLink = data.feed.links.find(link => link.id === linkId);\n      votedLink.votes = createVote.link.votes; // retrieving the link that the user just voted for from that list.\n      // You’re also manipulating that link by resetting its votes to the votes that were just returned by the server\n\n      store.writeQuery({\n        query: FEED_QUERY,\n        data\n      }); // take the modified data and write it back into the store\n    };\n\n    this._subscribeToNewLinks = subscribeToMore => {\n      subscribeToMore({\n        document: NEW_LINKS_SUBSCRIPTION,\n        updateQuery: (prev, {\n          subscriptionData\n        }) => {\n          if (!subscriptionData.data) return prev;\n          const newLink = subscriptionData.data.newLink;\n          const exists = prev.feed.links.find(({\n            id\n          }) => id === newLink.id);\n          if (exists) return prev;\n          return Object.assign({}, prev, {\n            feed: {\n              links: [newLink, ...prev.feed.links],\n              count: prev.feed.links.length + 1,\n              __typename: prev.feed.__typename\n            }\n          });\n        }\n      });\n    };\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Query, {\n      query: FEED_QUERY,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66,\n        columnNumber: 7\n      }\n    }, ({\n      loading,\n      error,\n      data,\n      subscribeToMore\n    }) => {\n      if (loading) return /*#__PURE__*/React.createElement(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 31\n        }\n      }, \"Fetching\"); // loading: Is true as long as the request is still ongoing and the response hasn’t been received.\n\n      if (error) return /*#__PURE__*/React.createElement(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 70,\n          columnNumber: 29\n        }\n      }, \"Error\"); // error: In case the request fails, this field will contain information about what exactly went wrong.\n\n      this._subscribeToNewLinks(subscribeToMore); // using subscribeToMore received as prop into the component’s render prop function.\n      // Calling _subscribeToNewLinks with its respective subscribeToMore function you make sure that the component actually subscribes to the events.\n      // This call opens up a websocket connection to the subscription server\n\n\n      const linksToRender = data.feed.links; // data: This is the actual data that was received from the server. It has the links property which represents a list of Link elements.\n\n      return /*#__PURE__*/React.createElement(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 81,\n          columnNumber: 13\n        }\n      }, linksToRender.map((link, index) => /*#__PURE__*/React.createElement(Link, {\n        key: link.id,\n        link: link,\n        index: index,\n        updateStoreAfterVote: this._updateCacheAfterVote,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 83,\n          columnNumber: 17\n        }\n      })));\n    });\n  }\n\n}\n\nexport default LinkList;","map":{"version":3,"sources":["/Users/madisonmccardle/PCA/javascipt/react/hacker-news-react-apollo/src/components/LinkList.js"],"names":["React","Component","Link","Query","gql","FEED_QUERY","LinkList","_updateCacheAfterVote","store","createVote","linkId","data","readQuery","query","votedLink","feed","links","find","link","id","votes","writeQuery","_subscribeToNewLinks","subscribeToMore","document","NEW_LINKS_SUBSCRIPTION","updateQuery","prev","subscriptionData","newLink","exists","Object","assign","count","length","__typename","render","loading","error","linksToRender","map","index"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport Link from './Link'\nimport { Query } from 'react-apollo'\nimport gql from 'graphql-tag'\n\nexport const FEED_QUERY = gql`\n{\n  feed {\n    links {\n      id\n      createdAt\n      url\n      description\n      postedBy {\n        id\n        name\n      }\n      votes {\n        id\n        user {\n          id\n        }\n      }\n    }\n  }\n}\n`\n// create the JavaScript constant called FEED_QUERY that stores the query.\n// The gql function is used to parse the plain string that contains the GraphQL code.\n\nclass LinkList extends Component {\n  _updateCacheAfterVote = (store, createVote, linkId) => {\n    const data = store.readQuery({ query: FEED_QUERY })\n    // eading the current state of the cached data for the FEED_QUERY from the store\n    const votedLink = data.feed.links.find(link => link.id === linkId)\n    votedLink.votes = createVote.link.votes\n    // retrieving the link that the user just voted for from that list.\n    // You’re also manipulating that link by resetting its votes to the votes that were just returned by the server\n    store.writeQuery({ query: FEED_QUERY, data })\n    // take the modified data and write it back into the store\n  }\n\n  _subscribeToNewLinks = subscribeToMore => {\n    subscribeToMore({\n      document: NEW_LINKS_SUBSCRIPTION,\n      updateQuery: (prev, { subscriptionData }) => {\n        if (!subscriptionData.data) return prev\n        const newLink = subscriptionData.data.newLink\n        const exists = prev.feed.links.find(({ id }) => id === newLink.id);\n        if (exists) return prev;\n\n        return Object.assign({}, prev, {\n          feed: {\n            links: [newLink, ...prev.feed.links],\n            count: prev.feed.links.length + 1,\n            __typename: prev.feed.__typename\n          }\n        })\n      }\n    })\n  }\n\n  render() {\n\n    return (\n      <Query query={FEED_QUERY}>\n        {({ loading, error, data, subscribeToMore }) => {\n          if (loading) return <div>Fetching</div>\n          // loading: Is true as long as the request is still ongoing and the response hasn’t been received.\n          if (error) return <div>Error</div>\n          // error: In case the request fails, this field will contain information about what exactly went wrong.\n\n          this._subscribeToNewLinks(subscribeToMore)\n          // using subscribeToMore received as prop into the component’s render prop function.\n          // Calling _subscribeToNewLinks with its respective subscribeToMore function you make sure that the component actually subscribes to the events.\n          // This call opens up a websocket connection to the subscription server\n\n          const linksToRender = data.feed.links\n          // data: This is the actual data that was received from the server. It has the links property which represents a list of Link elements.\n          return (\n            <div>\n              {linksToRender.map((link, index) => (\n                <Link\n                  key={link.id}\n                  link={link}\n                  index={index}\n                  updateStoreAfterVote={this._updateCacheAfterVote}\n                />\n              ))}\n            </div>\n          )\n        }}\n      </Query>\n    )\n  }\n}\n\nexport default LinkList\n"]},"metadata":{},"sourceType":"module"}